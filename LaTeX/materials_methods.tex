% !TEX root = ./main.tex
\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Resources}

The most important resource to be used in this study will be Wikipedia and the countless articles written regarding this subject. The programming language used to implement and time the algorithms will be Python\footnote{Although Python is one of the slowest languages, the simplicity of it makes it an invaluable tool for this study.} \cite{python}.

As of today, the largest primes are found using supercomputers running these algorithms. Using a supercomputer is not plausible for this study, therefore the maxmimum limit for primes will be $10^{14}$.

\subsection{Methods}
During the primality testing \cite{prime:test} there will be two test cases for the algorithms. The first one will determine if $n$ is a prime or composite, and the second one will generate the largest prime within a time limit. At the start of the code a driver function will be defined to serve as the "starter" code for the program - deciding what test to perform. The driver function will call a primality testing function called \textbf{primeTest} which will return a boolean\footnote{A function that returns $True$ or $False$} value. 

Two groups of algorithms will be tested: the "simple" methods and the probabilistic tests. The driver function will be called to start a timer and execute one of the following algorithms:
\begin{enumerate}
    \item "Simple" methods
    \begin{enumerate}
        \item Brute-force%O(N)
        \item Smart Brute-force %O(sqrt(n))
        \item Sieve of Eratosthenes \cite{prime:sieve}
    \end{enumerate}
    \item Probabilistic tests \cite{prime:test}
    \begin{enumerate}
        \item Fermat Primality
        \item Miller–Rabin
    \end{enumerate}
\end{enumerate}

\vspace{10mm}

The function will be called upon three times to average an "accurate" runtime. The same integers will be used across all tests. These runtimes are noted and later compared in the discussion. The following Python code describes the setup:

\begin{python}
    import time
    # from ALGORITHM_FILE import ALGORITHM

    def driver():
        numbers = [...] # Values to be appended
        times = []
        for n in numbers:
            start = time.time()
            primeTest(n)
            runTime = time.time() - start
            times.append(runTime)
        print(sum(times) / len(times))

    def primeTest(n):
        if Algorithm(n): # Algorithm function
            return True
        return False

    if __name__ == "__main__":
        driver()
\end{python}

Important to note is that the algorithms will be stored in a seperate file. At the beginning of the main file the algorithms will be imported. To see further details and the $.py$ files, refer to the essays GitHub page \cite{github}.

\vspace{10mm}

To generate the largest prime within 30 seconds, the \textbf{primeTest} function will remain the same, however the driver function will recieve some changes. Study the following code:

\begin{python}
    def driver():
        n = 2
        primes = []
        timelimit = time.time() + 30  # Thirty seconds limit
        while (time.time() < timelimit):
            if primeTest(n):
                primes.append(n)
            n += 1
        print(max(primes))
\end{python}

\subsection{Algorithms}

\subsubsection{Brute-force}

\subsubsection{Smart Brute-force}

\subsubsection{Sieve of Eratosthenes}

\subsubsection{Fermat Primality}

\subsubsection{Miller–Rabin}


\end{document}
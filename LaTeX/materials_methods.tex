% !TEX root = ./main.tex
\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Resources}

The most important resource to be used in this study will be Wikipedia and the countless articles written regarding this subject. The programming language used to implement and time the algorithms will be Python\footnote{Although Python is one of the slowest languages, the simplicity of it makes it an invaluable tool for this study.} \cite{python}.

As of today, the largest primes are found using supercomputers running these algorithms. Using a supercomputer is not plausible for this study, therefore the maxmimum limit for primes will be $10^{14}$.

\subsection{Methods}
During the primality testing \cite{prime:test} there will be two test cases for the algorithms. The first one will determine if $n$ is a prime or composite, and the second one will generate the largest prime within a time limit. At the start of the code a driver function will be defined to serve as the "starter" code for the program - deciding what test to perform. The driver function will call a primality testing function called \textbf{primeTest} which will return a boolean\footnote{A function that returns $True$ or $False$} value. 

Two groups of algorithms will be tested: the deterministic and the probabilistic tests. The driver function will be called to start a timer and execute one of the following algorithms:
\begin{enumerate}
    \item Deterministic tests \cite{algh:determ}
    \begin{enumerate}
        \item Brute-force
        \item Smart Brute-force
        \item AKS Primality Test \cite{algh:AKS}
    \end{enumerate}
    \item Probabilistic tests \cite{algh:probab}
    \begin{enumerate}
        \item Fermat Primality \cite{algh:fermat}
        \item Miller–Rabin \cite{algh:miller}
    \end{enumerate}
\end{enumerate}

\vspace{10mm}

The function will be called upon five times to average an "accurate" runtime. The same integers will be used across all tests. These runtimes are noted and later compared in the discussion. The following Python code describes the setup:

\begin{python}
    import time
    # from FILE import ALGORITHM

    def driver():
        numbers = [...] # Values to be appended
        times = []
        for n in numbers:
            start = time.time()
            primeTest(n)
            runTime = time.time() - start
            times.append(runTime)
        print(sum(times) / len(times))

    def primeTest(n):
        if ALGORITHM(n): # Algorithm function
            return True
        return False

    if __name__ == "__main__":
        driver()
\end{python}

The algorithms will be stored in a seperate file, hence the \textit{from FILE import ALGORITHM} at the top of the code. To see further details and the $*.py$ files, refer to the essays GitHub page \cite{github}.
\newline
\\*
To generate the largest prime within $30$ seconds, the \textbf{primeTest} function will remain the same, however the driver function will recieve some changes:

\begin{python}
    def driver():
        n = 2
        primes = []
        timelimit = time.time() + 30  # Thirty seconds limit
        while (time.time() < timelimit):
            if primeTest(n):
                primes.append(n)
            n += 1
        print(max(primes))
\end{python}



\subsection{Algorithms}

Vi skriver lite trivia och importance om algoritmer

\subsubsection{Brute-force}

This is the Brute-force algorithm.

\begin{python}
    def brute(n):
        for x in range(2, n):
            if n % x == 0:
                return False
        return True
\end{python}

\vspace{10mm}

This is the Smart Brute-force algorithm.

\begin{python}
    import math

    def smartBrute(n):
        if n == 1:
            return False
        if n == 2:

            return True
        for x in range(3, math.sqrt(n), 2):
            if n % x == 0:
                return False
        return True
\end{python}

\subsubsection{AKS Primality Test}

\subsubsection{Fermat Primality}

\subsubsection{Miller–Rabin}

\end{document}
% !TEX root = ./main.tex
\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Resources}

The most important resource to be used in this study will be Wikipedia and the countless articles written regarding this subject. The programming language used to implement and time the algorithms will be Python\footnote{Although Python is one of the slowest languages, the simplicity of it makes it an invaluable tool for this study.} \cite{python}.

As of today, the largest primes are found using supercomputers running these algorithms. Using a supercomputer is not plausible for this study, therefore the maxmimum limit for primes will be $10^{14}$.

\subsection{Methods}
During the primality testing \cite{prime:test} there will be two test cases for the algorithms. The first one will determine if $n$ is a prime or composite, and the second one will generate the largest prime within a time limit. At the start of the code a driver function will be defined to serve as the "starter" code for the program - deciding what test to perform. The driver function will call a primality testing function called \textbf{primeTest} which will return a boolean\footnote{A function that returns $True$ or $False$} value. 

Two groups of algorithms will be tested: the "simple" methods and the probabilistic tests. The driver function will be called to start a timer and execute one of the following algorithms:
\begin{enumerate}
    \item "Simple" methods
    \begin{enumerate}
        \item Brute-force%O(N)
        \item Smart Brute-force %O(sqrt(n))
        \item Sieve of Eratosthenes \cite{prime:sieve}
    \end{enumerate}
    \item Probabilistic tests \cite{prime:test}
    \begin{enumerate}
        \item Fermat Primality
        \item Miller–Rabin
    \end{enumerate}
\end{enumerate}

\vspace{10mm}

The function will be called upon three times to average an "accurate" runtime. The same integers will be used across all tests. These runtimes are noted and later compared in the discussion. The following Python code describes the setup:

\begin{python}
    import time
    # from FILE import ALGORITHM

    def driver():
        numbers = [...] # Values to be appended
        times = []
        for n in numbers:
            start = time.time()
            primeTest(n)
            runTime = time.time() - start
            times.append(runTime)
        print(sum(times) / len(times))

    def primeTest(n):
        if ALGORITHM(n): # Algorithm function
            return True
        return False

    if __name__ == "__main__":
        driver()
\end{python}

The algorithms will be stored in a seperate file, hence the \textit{from FILE import ALGORITHM} at the top of the code. To see further details and the $*.py$ files, refer to the essays GitHub page \cite{github}.
\newline
\\*
To generate the largest prime within $30$ seconds, the \textbf{primeTest} function will remain the same, however the driver function will recieve some changes:

\begin{python}
    def driver():
        n = 2
        primes = []
        timelimit = time.time() + 30  # Thirty seconds limit
        while (time.time() < timelimit):
            if primeTest(n):
                primes.append(n)
            n += 1
        print(max(primes))
\end{python}

\subsection{Algorithms}

\subsubsection{Brute-force}

\begin{python}
    def brute(n):
        for x in range(2, n):
            if n % x == 0:
                return False
        return True
\end{python}

\subsubsection{Smart Brute-force}

\begin{python}
    import math

    def smartBrute(n):
        if n == 1:
            return False
        if n == 2:
            return True
        for x in range(3, math.sqrt(n), 2):
            if n % x == 0:
                return False
        return True
\end{python}

\subsubsection{Sieve of Eratosthenes}

\begin{python}
    import math

    def sieve(N):
        length = N + 1
        nums = [True] * length

        for i in range(2, math.isqrt(length)):
            if not nums[i]:
                continue
            for j in range(i + 1, length):
                if j % i == 0:
                    nums[j] = False

        # Print all primes
        for x in range(2, length):
            if nums[x]:
                print(x)
\end{python}

\subsubsection{Fermat Primality}

\subsubsection{Miller–Rabin}

\end{document}